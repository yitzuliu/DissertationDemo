<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vision Intelligence Hub - Unified Interface</title>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Styles -->
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/responsive.css">
    
    <style>
        .unified-container {
            height: calc(100vh - var(--header-height) - 2rem);
            margin: 1rem auto;
            padding: 0 var(--padding-lg);
            display: grid;
            grid-template-columns: 50% 50%;
            gap: 24px;
            overflow: hidden;
        }

        .vision-panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .query-panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-light);
        }

        .panel-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title i {
            color: var(--primary);
        }

        .vision-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow: hidden;
        }

        .query-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow: hidden;
        }

        .video-container {
            position: relative;
            border-radius: var(--radius-md);
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.9);
            box-shadow: var(--shadow-sm);
            margin-bottom: 0.5rem;
            flex-grow: 1;
        }

        .video-preview {
            width: 100%;
            height: 100%;
            border-radius: var(--radius-md);
            background: linear-gradient(to bottom right, #101010, #232323);
            object-fit: cover;
            transition: var(--transition);
        }

        .video-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: var(--radius-md);
            border: 2px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }

        /* Compact Query Input Section */
        .query-input-section {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-light);
            margin-bottom: 0.5rem;
        }

        .input-group {
            margin-bottom: 0.75rem;
        }

        .input-group:last-child {
            margin-bottom: 0;
        }

        .input-label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 600;
            font-size: 0.8rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .ai-prompt-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            font-size: 0.8rem;
            background-color: #fff;
            color: var(--text);
            transition: var(--transition);
            resize: vertical;
            min-height: 40px;
            max-height: 80px;
        }

        .ai-prompt-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-light);
        }

        .state-query-group {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
        }

        .state-query-input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            font-size: 0.8rem;
            background-color: #fff;
            color: var(--text);
            transition: var(--transition);
        }

        .state-query-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-light);
        }

        .query-button {
            padding: 0.5rem 1rem;
            background: var(--gradient-primary);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
        }

        .query-button:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        .query-examples {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .example-query {
            padding: 0.2rem 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-size: 0.7rem;
            color: var(--text-light);
            cursor: pointer;
            transition: var(--transition);
        }

        .example-query:hover {
            background: var(--primary-light);
            color: var(--primary-dark);
        }

        /* Unified Response Section */
        .response-section {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-light);
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .response-content {
            flex: 1;
            overflow-y: auto;
            max-height: 300px;
        }

        .response-item {
            margin-bottom: 0.75rem;
            padding: 0.75rem;
            border-radius: var(--radius-md);
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .response-item:last-child {
            margin-bottom: 0;
        }

        .response-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .response-title {
            flex: 1;
        }

        .response-time {
            color: var(--text-light);
            font-size: 0.7rem;
        }

        .response-content-text {
            color: var(--text);
        }

        /* Response Types */
        .response-item.vision-response {
            background: linear-gradient(135deg, #dbeafe, #eff6ff);
            border-left: 3px solid #3b82f6;
        }

        .response-item.query-response {
            background: linear-gradient(135deg, #d1fae5, #ecfdf5);
            border-left: 3px solid #10b981;
        }

        .response-item.system-message {
            background: linear-gradient(135deg, #fef3c7, #fffbeb);
            border-left: 3px solid #f59e0b;
        }

        /* Controls Section */
        .controls-section {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 0.75rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-light);
        }

        .control-group {
            margin-bottom: 0.5rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: block;
            margin-bottom: 0.15rem;
            font-weight: 600;
            font-size: 0.7rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .control-input {
            width: 100%;
            padding: 0.3rem;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            font-size: 0.7rem;
            background-color: #fff;
            color: var(--text);
            transition: var(--transition);
        }

        .control-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-light);
        }

        .parameter-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.4rem;
        }

        .parameter-grid .control-group:first-child {
            grid-column: 1 / -1;
        }

        .parameter-grid .start-button {
            grid-column: 1 / -1;
        }

        .start-button {
            width: 100%;
            padding: 0.5rem;
            background: var(--gradient-primary);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
        }

        .start-button.danger {
            background: var(--error);
        }

        .start-button.danger:hover {
            background-color: rgba(220, 38, 38, 0.9);
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.25);
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            color: var(--text-light);
            padding: 1rem;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-light);
            border-top: 2px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            font-size: 0.8rem;
            font-weight: 500;
        }

        .status-connected {
            background: var(--success-light);
            color: var(--success);
        }

        .status-disconnected {
            background: var(--error-light);
            color: var(--error);
        }

        /* Navigation links */
        .header-status a {
            text-decoration: none;
            color: inherit;
            transition: var(--transition);
        }

        .header-status a:hover {
            background: var(--primary-light);
            color: var(--primary-dark);
            transform: translateY(-1px);
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .unified-container {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .vision-panel, .query-panel {
                height: auto;
                min-height: 400px;
            }
        }

        @media (max-width: 768px) {
            .unified-container {
                padding: 0 1rem;
                margin: 0.5rem auto;
            }
            
            .state-query-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .query-examples {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="logo">
            <i class="fas fa-brain"></i>
            <span>Vision Intelligence Hub - Unified Interface</span>
        </div>
        <div class="header-status">
            <div id="connectionStatus" class="status-item status-disconnected">
                <span class="status-dot"></span>
                <span>Disconnected</span>
            </div>
            <a href="ai_vision_analysis.html" class="status-item" style="text-decoration: none; color: inherit;">
                <i class="fas fa-camera"></i>
                <span>AI Vision Analysis</span>
            </a>
            <a href="query.html" class="status-item" style="text-decoration: none; color: inherit;">
                <i class="fas fa-search"></i>
                <span>Query Only</span>
            </a>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <div class="unified-container">
            <!-- Vision Analysis Panel -->
            <div class="vision-panel">
                <div class="panel-header">
                    <h2 class="panel-title">
                        <i class="fas fa-video"></i>
                        Vision Analysis
                    </h2>
                </div>
                
                <div class="vision-content">
                    <!-- Video Container -->
                    <div class="video-container">
                        <video id="videoFeed" class="video-preview" autoplay playsinline></video>
                        <canvas id="canvas" style="display:none;"></canvas>
                    </div>
                    
                    <!-- Controls Section -->
                    <div class="controls-section">
                        <div class="parameter-grid">
                            <div class="control-group">
                                <label for="cameraSelect" class="control-label">Camera Selection</label>
                                <select id="cameraSelect" class="control-input"></select>
                            </div>
                            
                            <div class="control-group">
                                <label for="intervalSelect" class="control-label">Capture Rate</label>
                                <select id="intervalSelect" class="control-input">
                                    <option value="2000">2 seconds</option>
                                    <option value="3000">3 seconds</option>
                                    <option value="5000">5 seconds</option>
                                </select>
                            </div>
                            
                            <div class="control-group">
                                <label for="qualitySelect" class="control-label">Image Quality</label>
                                <select id="qualitySelect" class="control-input">
                                    <option value="0.7">Fast</option>
                                    <option value="0.8">Medium</option>
                                    <option value="0.9" selected>High</option>
                                </select>
                            </div>
                            
                            <div class="control-group">
                                <label for="tokensSelect" class="control-label">Max Tokens</label>
                                <select id="tokensSelect" class="control-input">
                                    <option value="100" selected>100</option>
                                    <option value="200">200</option>
                                    <option value="300">300</option>
                                </select>
                            </div>
                            
                            <button id="startButton" class="start-button">
                                <i class="fas fa-play"></i>
                                <span>Start Vision Analysis</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Query Panel -->
            <div class="query-panel">
                <div class="panel-header">
                    <h2 class="panel-title">
                        <i class="fas fa-search"></i>
                        Query & Response
                    </h2>
                </div>
                
                <div class="query-content">
                    <!-- Query Input Section -->
                    <div class="query-input-section">
                        <!-- AI Vision Analysis Prompt -->
                        <div class="input-group">
                            <label for="instructionText" class="input-label">Ask about the image:</label>
                            <textarea 
                                id="instructionText" 
                                class="ai-prompt-input" 
                                rows="2" 
                                placeholder="Describe what you want to analyze in the image..."
                            ></textarea>
                        </div>

                        <!-- State Query -->
                        <div class="input-group">
                            <label for="queryInput" class="input-label">Ask about your current state:</label>
                            <div class="state-query-group">
                                <input 
                                    type="text" 
                                    id="queryInput" 
                                    class="state-query-input" 
                                    placeholder="What step am I on?"
                                    autocomplete="off"
                                >
                                <button id="queryButton" class="query-button">
                                    <i class="fas fa-search"></i>
                                    Query
                                </button>
                            </div>
                        </div>
                        
                        <div class="query-examples">
                            <div class="example-query" data-query="Where am I?">Where am I?</div>
                            <div class="example-query" data-query="What is the current step?">What is the current step?</div>
                            <div class="example-query" data-query="What tools do I need?">What tools do I need?</div>
                            <div class="example-query" data-query="What's my progress?">What's my progress?</div>
                            <div class="example-query" data-query="Help me with this step">Help me with this step</div>
                            <div class="example-query" data-query="What's next?">What's next?</div>
                        </div>
                    </div>

                    <!-- Unified Response Section -->
                    <div class="response-section">
                        <div class="response-content">
                            <div id="responseLoading" class="loading" style="display: none;">
                                <div class="spinner"></div>
                                Processing your request...
                            </div>
                            
                            <div id="responseContainer">
                                <div class="response-item system-message">
                                    <div class="response-header">
                                        <i class="fas fa-info-circle"></i>
                                        <span class="response-title">Welcome</span>
                                        <span class="response-time">Now</span>
                                    </div>
                                    <div class="response-content-text">
                                        Welcome to the unified interface! Use the left panel for vision analysis and the right panel for queries and responses.
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- JavaScript Modules -->
    <script type="module">
        // Unified Application - Inline Version
        // This fixes the module loading issues by using inline JavaScript

        // Frontend Visual Logging System
        class FrontendVisualLogger {
            constructor() {
                this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.logToConsole = true;
                this.logToServer = false;
                this.observationId = null;
            }

            generateObservationId() {
                const timestamp = Date.now();
                this.observationId = `obs_${timestamp}_${Math.random().toString(36).substr(2, 8)}`;
                return this.observationId;
            }

            log(eventType, data) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    sessionId: this.sessionId,
                    eventType: eventType,
                    data: data
                };

                if (this.logToConsole) {
                    console.log(`[FrontendVisualLog] ${eventType}:`, data);
                }
            }

            logEyesCapture(observationId, requestId, deviceInfo, imageData) {
                this.log('EYES_CAPTURE', {
                    observation_id: observationId,
                    request_id: requestId,
                    device: deviceInfo.device,
                    resolution: imageData.resolution,
                    quality: imageData.quality,
                    format: imageData.format,
                    size: imageData.size,
                    timestamp: Date.now()
                });
            }

            logEyesPrompt(observationId, prompt) {
                this.log('EYES_PROMPT', {
                    observation_id: observationId,
                    prompt: prompt,
                    length: prompt.length,
                    timestamp: Date.now()
                });
            }

            logEyesTransfer(observationId, transferData) {
                this.log('EYES_TRANSFER', {
                    observation_id: observationId,
                    sent_to_backend: transferData,
                    timestamp: Date.now()
                });
            }

            logPageLoad() {
                this.log('PAGE_LOAD', {
                    url: window.location.href,
                    userAgent: navigator.userAgent,
                    timestamp: Date.now()
                });
            }

            logUserAction(action, details) {
                this.log('USER_ACTION', {
                    action: action,
                    details: details,
                    timestamp: Date.now()
                });
            }

            logError(error, context) {
                this.log('FRONTEND_ERROR', {
                    error: error.toString(),
                    context: context,
                    stack: error.stack,
                    timestamp: Date.now()
                });
            }
        }

        // Initialize frontend logger
        let frontendLogger;
        try {
            frontendLogger = new FrontendVisualLogger();
            console.log("‚úÖ Frontend logger initialized successfully");
        } catch (error) {
            console.error("‚ùå Failed to initialize frontend logger:", error);
            frontendLogger = {
                generateObservationId: () => `obs_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`,
                logPageLoad: () => { },
                logError: () => { },
                logEyesCapture: () => { },
                logEyesPrompt: () => { },
                logEyesTransfer: () => { },
                logUserAction: () => { },
                log: () => { }
            };
        }

        // Unified API Client
        class UnifiedAPIClient {
            constructor() {
                this.baseURL = 'http://localhost:8000';
                this.apiBaseUrl = `${this.baseURL}/api/v1`;
            }

            async checkStatus() {
                try {
                    const response = await fetch(`${this.baseURL}/status`, {
                        signal: AbortSignal.timeout(5000)
                    });

                    if (response.ok) {
                        return await response.json();
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    throw error;
                }
            }

            async loadConfig() {
                try {
                    const response = await fetch(`${this.baseURL}/config`, {
                        signal: AbortSignal.timeout(3000)
                    });

                    if (!response.ok) {
                        throw new Error("Failed to load configuration");
                    }

                    return await response.json();
                } catch (error) {
                    console.error("Failed to load config:", error);
                    return null;
                }
            }

            async sendStateQuery(query, queryId) {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/state/query`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            query: query,
                            query_id: queryId
                        }),
                        signal: AbortSignal.timeout(10000)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Server error: ${response.status} - ${errorText}`);
                    }

                    const data = await response.json();
                    return data;
                } catch (error) {
                    throw error;
                }
            }

            async sendVisionAnalysis(instruction, imageResult, maxTokens = 100) {
                let imageBase64URL, observationId;
                
                if (typeof imageResult === 'string') {
                    imageBase64URL = imageResult;
                    observationId = frontendLogger && frontendLogger.generateObservationId ? 
                        frontendLogger.generateObservationId() : 
                        `obs_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
                } else if (imageResult && typeof imageResult === 'object') {
                    imageBase64URL = imageResult.dataURL;
                    observationId = imageResult.observationId;
                } else {
                    throw new Error('Invalid image data format');
                }

                try {
                    if (frontendLogger && frontendLogger.logEyesPrompt) {
                        frontendLogger.logEyesPrompt(observationId, instruction);
                    }
                } catch (error) {
                    console.warn("‚ö†Ô∏è Failed to log eyes prompt:", error);
                }

                const requestBody = {
                    max_tokens: maxTokens,
                    messages: [
                        {
                            role: 'user',
                            content: [
                                { type: 'text', text: instruction },
                                { type: 'image_url', image_url: { url: imageBase64URL } }
                            ]
                        }
                    ]
                };

                try {
                    if (frontendLogger && frontendLogger.logEyesTransfer) {
                        frontendLogger.logEyesTransfer(observationId, {
                            max_tokens: maxTokens,
                            instruction_length: instruction.length,
                            has_image: true,
                            image_format: imageBase64URL.split(';')[0].replace('data:image/', ''),
                            request_size_estimate: `${Math.round(JSON.stringify(requestBody).length / 1024)}KB`
                        });
                    }
                } catch (error) {
                    console.warn("‚ö†Ô∏è Failed to log eyes transfer:", error);
                }

                const response = await fetch(`${this.baseURL}/v1/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: AbortSignal.timeout(30000)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                
                if (!data || !data.choices || !Array.isArray(data.choices) || data.choices.length === 0) {
                    throw new Error('Invalid API response format');
                }

                if (!data.choices[0].message || !data.choices[0].message.content) {
                    throw new Error('Invalid message format in API response');
                }

                return data.choices[0].message.content;
            }

            generateQueryId() {
                return `query_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
            }

            detectLanguage(text) {
                const chinesePattern = /[\u4e00-\u9fff]/;
                const englishPattern = /[a-zA-Z]/;
                
                if (chinesePattern.test(text)) return 'zh';
                if (englishPattern.test(text)) return 'en';
                return 'unknown';
            }

            async logUserQuery(queryData) {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/logging/user_query`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(queryData),
                        signal: AbortSignal.timeout(2000)
                    });

                    if (!response.ok) {
                        console.warn('Failed to log user query:', response.status);
                    }
                } catch (error) {
                    console.warn('Failed to log user query:', error);
                }
            }
        }

        // Camera Manager
        class CameraManager {
            constructor() {
                this.stream = null;
                this.video = null;
                this.canvas = null;
                this.cameraSelect = null;
                this.isReady = false;
            }

            async initialize(videoElement, canvasElement, cameraSelectElement) {
                this.video = videoElement;
                this.canvas = canvasElement;
                this.cameraSelect = cameraSelectElement;

                try {
                    await this.populateCameraList();
                    this.isReady = true;
                    console.log('‚úÖ Camera manager initialized successfully');
                } catch (error) {
                    console.error('‚ùå Failed to initialize camera manager:', error);
                    throw error;
                }
            }

            async populateCameraList() {
                try {
                    await navigator.mediaDevices.getUserMedia({ video: true, audio: false });

                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');

                    if (videoDevices.length === 0) {
                        throw new Error("No cameras found");
                    }

                    this.cameraSelect.innerHTML = videoDevices.map(device => {
                        const isIPhone = device.label.toLowerCase().includes('continuity') ||
                            device.label.toLowerCase().includes('iphone');
                        const isMacBook = device.label.toLowerCase().includes('facetime') ||
                            device.label.toLowerCase().includes('built-in');
                        const isExternal = device.label.toLowerCase().includes('usb') ||
                            device.label.toLowerCase().includes('capture');

                        let icon = 'üì∑ ';
                        if (isIPhone) icon = 'üì± ';
                        else if (isMacBook) icon = 'üíª ';
                        else if (isExternal) icon = 'üé• ';

                        const label = device.label || `Camera ${videoDevices.indexOf(device) + 1}`;
                        return `<option value="${device.deviceId}">${icon}${label}</option>`;
                    }).join('');

                    const macBookCamera = videoDevices.find(d =>
                        d.label.toLowerCase().includes('facetime') ||
                        d.label.toLowerCase().includes('built-in')
                    );

                    const selectedCamera = macBookCamera || videoDevices[0];
                    this.cameraSelect.value = selectedCamera.deviceId;
                    await this.startCamera(selectedCamera.deviceId);

                } catch (err) {
                    console.error("Error accessing cameras:", err);
                    throw err;
                }
            }

            async startCamera(deviceId) {
                try {
                    if (this.stream) {
                        this.stream.getTracks().forEach(track => track.stop());
                    }

                    const constraints = {
                        video: {
                            deviceId: deviceId ? { exact: deviceId } : undefined,
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            facingMode: deviceId ? undefined : "user"
                        },
                        audio: false
                    };

                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;

                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Video metadata loading timeout'));
                        }, 10000);

                        this.video.onloadedmetadata = () => {
                            clearTimeout(timeout);
                            this.video.classList.add('animate-fade-in');
                            console.log(`Camera started: ${this.video.videoWidth}x${this.video.videoHeight}`);
                            resolve();
                        };

                        this.video.onerror = (error) => {
                            clearTimeout(timeout);
                            reject(error);
                        };
                    });

                } catch (err) {
                    console.error("Error starting camera:", err);
                    throw err;
                }
            }

            captureImage(quality = 0.9) {
                if (!this.stream) {
                    console.error("‚ùå No camera stream available");
                    return null;
                }

                if (!this.video || this.video.readyState < 2) {
                    console.error("‚ùå Video not ready, readyState:", this.video ? this.video.readyState : 'video element not found');
                    return null;
                }

                if (!this.video.videoWidth || !this.video.videoHeight) {
                    console.error("‚ùå Video dimensions not available:", this.video.videoWidth, 'x', this.video.videoHeight);
                    return null;
                }

                try {
                    let observationId;
                    try {
                        observationId = (typeof frontendLogger !== 'undefined' && frontendLogger.generateObservationId)
                            ? frontendLogger.generateObservationId()
                            : `obs_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
                    } catch (idError) {
                        console.warn("‚ö†Ô∏è ID generation failed, using fallback:", idError);
                        observationId = `obs_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
                    }

                    const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;

                    const targetWidth = 1024;
                    const aspectRatio = this.video.videoHeight / this.video.videoWidth;
                    const targetHeight = Math.round(targetWidth * aspectRatio);

                    this.canvas.width = targetWidth;
                    this.canvas.height = targetHeight;

                    const ctx = this.canvas.getContext('2d');
                    if (!ctx) {
                        console.error("‚ùå Failed to get canvas 2D context");
                        return null;
                    }

                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';

                    try {
                        ctx.drawImage(this.video, 0, 0, targetWidth, targetHeight);
                    } catch (drawError) {
                        console.error("‚ùå Failed to draw video to canvas:", drawError);
                        return null;
                    }

                    const imageQuality = Math.max(0.92, parseFloat(quality) || 0.9);

                    let imageDataURL;
                    try {
                        imageDataURL = this.canvas.toDataURL('image/jpeg', imageQuality);
                    } catch (dataUrlError) {
                        console.error("‚ùå Failed to convert canvas to data URL:", dataUrlError);
                        return null;
                    }

                    if (!imageDataURL || imageDataURL.length < 100) {
                        console.error("‚ùå Generated image data is invalid or too small, length:", imageDataURL ? imageDataURL.length : 0);
                        return null;
                    }

                    if (!imageDataURL.startsWith('data:image/jpeg;base64,')) {
                        console.error("‚ùå Generated data URL has invalid format:", imageDataURL.substring(0, 50));
                        return null;
                    }

                    const selectedOption = this.cameraSelect.options[this.cameraSelect.selectedIndex];
                    const deviceInfo = {
                        device: selectedOption ? selectedOption.text : 'Unknown Camera'
                    };

                    const imageSizeBytes = Math.round((imageDataURL.length - 'data:image/jpeg;base64,'.length) * 3 / 4);

                    try {
                        if (typeof frontendLogger !== 'undefined' && frontendLogger.logEyesCapture) {
                            frontendLogger.logEyesCapture(observationId, requestId, deviceInfo, {
                                resolution: `${targetWidth}x${targetHeight}`,
                                quality: imageQuality,
                                format: 'jpeg',
                                size: `${(imageSizeBytes / 1024).toFixed(1)}KB`
                            });
                        }
                    } catch (logError) {
                        console.warn("‚ö†Ô∏è Logging failed but continuing:", logError);
                    }

                    const imageResult = {
                        dataURL: imageDataURL,
                        observationId: observationId,
                        requestId: requestId,
                        width: targetWidth,
                        height: targetHeight,
                        size: imageSizeBytes
                    };

                    console.log(`üéâ Image captured successfully: ${targetWidth}x${targetHeight}, ${(imageSizeBytes / 1024).toFixed(1)}KB`);
                    return imageResult;

                } catch (err) {
                    console.error("‚ùå Error in capture process:", err);
                    try {
                        if (typeof frontendLogger !== 'undefined' && frontendLogger.logError) {
                            frontendLogger.logError(err, 'image_capture');
                        }
                    } catch (logError) {
                        console.warn("‚ö†Ô∏è Error logging failed:", logError);
                    }
                    return null;
                }
            }

            cleanup() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
            }
        }

        // Unified UI Manager
        class UIManager {
            constructor() {
                this.elements = {};
                this.isInitialized = false;
                this.responseHistory = [];
                this.maxHistoryItems = 8;
            }

            initialize() {
                // Vision elements
                this.elements.videoFeed = document.getElementById('videoFeed');
                this.elements.canvas = document.getElementById('canvas');
                this.elements.cameraSelect = document.getElementById('cameraSelect');
                this.elements.intervalSelect = document.getElementById('intervalSelect');
                this.elements.qualitySelect = document.getElementById('qualitySelect');
                this.elements.tokensSelect = document.getElementById('tokensSelect');
                this.elements.startButton = document.getElementById('startButton');
                this.elements.instructionText = document.getElementById('instructionText');

                // Query panel elements
                this.elements.queryInput = document.getElementById('queryInput');
                this.elements.queryButton = document.getElementById('queryButton');
                this.elements.responseContainer = document.getElementById('responseContainer');
                this.elements.responseLoading = document.getElementById('responseLoading');

                // Status elements
                this.elements.connectionStatus = document.getElementById('connectionStatus');

                const requiredElements = [
                    'videoFeed', 'canvas', 'cameraSelect', 'startButton',
                    'queryInput', 'queryButton', 'responseContainer', 'connectionStatus'
                ];

                for (const elementName of requiredElements) {
                    if (!this.elements[elementName]) {
                        throw new Error(`Required element not found: ${elementName}`);
                    }
                }

                this.isInitialized = true;
                console.log('‚úÖ UI Manager initialized successfully');
            }

            updateConnectionStatus(isConnected, data = null) {
                if (!this.elements.connectionStatus) return;

                const statusDot = this.elements.connectionStatus.querySelector('.status-dot');
                const statusText = this.elements.connectionStatus.querySelector('span:last-child');

                if (isConnected) {
                    this.elements.connectionStatus.classList.remove('status-disconnected');
                    this.elements.connectionStatus.classList.add('status-connected');
                    if (statusDot) statusDot.classList.add('online');
                    if (statusDot) statusDot.classList.remove('offline');
                    if (statusText) statusText.textContent = 'Connected';
                } else {
                    this.elements.connectionStatus.classList.remove('status-connected');
                    this.elements.connectionStatus.classList.add('status-disconnected');
                    if (statusDot) statusDot.classList.add('offline');
                    if (statusDot) statusDot.classList.remove('online');
                    if (statusText) statusText.textContent = 'Disconnected';
                }
            }

            updateVisionProcessingState(isProcessing) {
                if (!this.elements.startButton) return;

                if (isProcessing) {
                    this.elements.startButton.innerHTML = '<i class="fas fa-stop"></i><span>Stop Vision Analysis</span>';
                    this.elements.startButton.classList.add('danger');
                } else {
                    this.elements.startButton.innerHTML = '<i class="fas fa-play"></i><span>Start Vision Analysis</span>';
                    this.elements.startButton.classList.remove('danger');
                }
            }

            addResponseItem(type, title, content, metadata = {}) {
                if (!this.elements.responseContainer) return;

                const responseItem = this.createResponseItem(type, title, content, metadata);
                
                this.responseHistory.unshift(responseItem);
                
                if (this.responseHistory.length > this.maxHistoryItems) {
                    this.responseHistory = this.responseHistory.slice(0, this.maxHistoryItems);
                }
                
                this.updateResponseDisplay();
                this.scrollToTop();
            }

            createResponseItem(type, title, content, metadata = {}) {
                const timestamp = new Date().toLocaleTimeString();
                
                return {
                    type,
                    title,
                    content,
                    timestamp,
                    metadata,
                    id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                };
            }

            updateResponseDisplay() {
                if (!this.elements.responseContainer) return;

                this.elements.responseContainer.innerHTML = this.responseHistory
                    .map(item => this.renderResponseItem(item))
                    .join('');
            }

            renderResponseItem(item) {
                const iconMap = {
                    'vision': 'fas fa-robot',
                    'query': 'fas fa-chart-line',
                    'system': 'fas fa-info-circle',
                    'error': 'fas fa-exclamation-triangle'
                };

                const icon = iconMap[item.type] || 'fas fa-comment';
                
                return `
                    <div class="response-item ${item.type}-response" data-id="${item.id}">
                        <div class="response-header">
                            <i class="${icon}"></i>
                            <span class="response-title">${item.title}</span>
                            <span class="response-time">${item.timestamp}</span>
                        </div>
                        <div class="response-content-text">
                            ${this.escapeHtml(item.content)}
                        </div>
                        ${this.renderMetadata(item.metadata)}
                    </div>
                `;
            }

            renderMetadata(metadata) {
                if (!metadata || Object.keys(metadata).length === 0) return '';

                const metaItems = [];
                if (metadata.processingTime) {
                    metaItems.push(`<span><i class="fas fa-clock"></i> ${metadata.processingTime}ms</span>`);
                }
                if (metadata.confidence) {
                    metaItems.push(`<span><i class="fas fa-percentage"></i> ${metadata.confidence}% confidence</span>`);
                }
                if (metadata.queryType) {
                    metaItems.push(`<span><i class="fas fa-tag"></i> ${metadata.queryType}</span>`);
                }

                if (metaItems.length === 0) return '';

                return `
                    <div class="response-meta" style="margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-light);">
                        ${metaItems.join(' ‚Ä¢ ')}
                    </div>
                `;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            scrollToTop() {
                const responseContent = document.querySelector('.response-content');
                if (responseContent) {
                    responseContent.scrollTop = 0;
                }
            }

            showVisionResponse(response) {
                this.addResponseItem(
                    'vision',
                    'Vision Analysis',
                    response,
                    { processingTime: Date.now() }
                );
            }

            showQueryResponse(response, type = 'State Query') {
                this.addResponseItem(
                    'query',
                    type,
                    response,
                    { queryType: type }
                );
            }

            showSystemMessage(message, title = 'System') {
                this.addResponseItem('system', title, message);
            }

            showError(message, type = 'general') {
                this.addResponseItem(
                    'error',
                    'Error',
                    message,
                    { errorType: type }
                );
            }

            showQueryLoading() {
                if (this.elements.responseLoading) {
                    this.elements.responseLoading.style.display = 'flex';
                }
            }

            hideQueryLoading() {
                if (this.elements.responseLoading) {
                    this.elements.responseLoading.style.display = 'none';
                }
            }

            getQueryInput() {
                return this.elements.queryInput ? this.elements.queryInput.value.trim() : '';
            }

            getInstructionText() {
                return this.elements.instructionText ? this.elements.instructionText.value.trim() : '';
            }

            getVisionSettings() {
                return {
                    interval: this.elements.intervalSelect ? this.elements.intervalSelect.value : '2000',
                    quality: this.elements.qualitySelect ? this.elements.qualitySelect.value : '0.9',
                    maxTokens: this.elements.tokensSelect ? this.elements.tokensSelect.value : '100'
                };
            }

            setupExampleQueries(callback) {
                const examples = document.querySelectorAll('.example-query');
                examples.forEach(example => {
                    example.addEventListener('click', () => {
                        const query = example.getAttribute('data-query');
                        if (query && this.elements.queryInput) {
                            this.elements.queryInput.value = query;
                            // Auto-trigger query after setting the text
                            setTimeout(() => {
                                if (callback) callback(query);
                            }, 100);
                        }
                    });
                });
            }

            setupKeyboardShortcuts(callbacks) {
                if (this.elements.queryInput) {
                    this.elements.queryInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            if (callbacks.onQuerySubmit) {
                                callbacks.onQuerySubmit();
                            }
                        }
                    });
                }

                if (this.elements.instructionText) {
                    this.elements.instructionText.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && e.ctrlKey) {
                            e.preventDefault();
                            if (callbacks.onVisionToggle) {
                                callbacks.onVisionToggle();
                            }
                        }
                    });
                }
            }
        }

        // Main Unified Application
        class UnifiedApp {
            constructor() {
                this.apiClient = new UnifiedAPIClient();
                this.cameraManager = new CameraManager();
                this.uiManager = new UIManager();
                
                this.isVisionProcessing = false;
                this.visionIntervalId = null;
                this.isInitialized = false;
            }

            async initialize() {
                try {
                    console.log('üöÄ Initializing Unified Vision Intelligence Hub...');

                    // Initialize UI manager
                    this.uiManager.initialize();

                    // Initialize camera manager
                    await this.cameraManager.initialize(
                        this.uiManager.elements.videoFeed,
                        this.uiManager.elements.canvas,
                        this.uiManager.elements.cameraSelect
                    );

                    // Check backend connection and load configuration
                    await Promise.allSettled([
                        this.checkBackendConnection(),
                        this.loadConfig()
                    ]);

                    // Set up event listeners
                    this.setupEventListeners();

                    // Set up keyboard shortcuts
                    this.setupKeyboardShortcuts();

                    this.isInitialized = true;
                    console.log('‚úÖ Unified application initialized successfully');

                } catch (error) {
                    console.error('‚ùå Failed to initialize unified application:', error);
                    this.uiManager.showError('Failed to initialize application. Please refresh the page.', 'initialization');
                }
            }

            async checkBackendConnection() {
                try {
                    const status = await this.apiClient.checkStatus();
                    this.uiManager.updateConnectionStatus(true, status);
                    console.log('‚úÖ Backend connected:', status);
                } catch (error) {
                    this.uiManager.updateConnectionStatus(false);
                    console.warn('‚ö†Ô∏è Backend not connected:', error.message);
                }
            }

            async loadConfig() {
                try {
                    const config = await this.apiClient.loadConfig();
                    
                    if (config) {
                        if (config.default_instruction && this.uiManager.elements.instructionText) {
                            this.uiManager.elements.instructionText.value = config.default_instruction;
                            console.log('‚úÖ Loaded default instruction:', config.default_instruction);
                        }

                        if (config.capture_intervals && Array.isArray(config.capture_intervals) && this.uiManager.elements.intervalSelect) {
                            this.uiManager.elements.intervalSelect.innerHTML = config.capture_intervals.map(interval =>
                                `<option value="${interval}">${interval / 1000}s</option>`
                            ).join('');
                            console.log('‚úÖ Loaded capture intervals:', config.capture_intervals);
                        }

                        if (config.model_help) {
                            console.log('‚úÖ Model help available:', config.model_help);
                        }
                    }
                } catch (error) {
                    console.error('Failed to load config:', error);
                }
            }

            setupEventListeners() {
                // Vision analysis start/stop button
                if (this.uiManager.elements.startButton) {
                    this.uiManager.elements.startButton.addEventListener('click', () => {
                        this.toggleVisionAnalysis();
                    });
                }

                // Query button
                if (this.uiManager.elements.queryButton) {
                    this.uiManager.elements.queryButton.addEventListener('click', () => {
                        this.processQuery();
                    });
                }

                // Camera selection change
                if (this.uiManager.elements.cameraSelect) {
                    this.uiManager.elements.cameraSelect.addEventListener('change', async () => {
                        const selectedDeviceId = this.uiManager.elements.cameraSelect.value;
                        await this.cameraManager.startCamera(selectedDeviceId);
                    });
                }

                // Example queries
                this.uiManager.setupExampleQueries((query) => {
                    console.log('Example query selected:', query);
                    // Auto-trigger the query
                    this.processQuery();
                });

                // Device change detection
                navigator.mediaDevices.addEventListener('devicechange', async () => {
                    console.log('Camera devices changed');
                    await this.cameraManager.populateCameraList();
                });
            }

            setupKeyboardShortcuts(callbacks) {
                this.uiManager.setupKeyboardShortcuts({
                    onQuerySubmit: () => this.processQuery(),
                    onVisionToggle: () => this.toggleVisionAnalysis()
                });
            }

            async toggleVisionAnalysis() {
                if (this.isVisionProcessing) {
                    this.stopVisionAnalysis();
                } else {
                    await this.startVisionAnalysis();
                }
            }

            async startVisionAnalysis() {
                const instruction = this.uiManager.getInstructionText();
                if (!instruction) {
                    this.uiManager.showError('Please enter a question about the image before starting.');
                    return;
                }

                this.isVisionProcessing = true;
                this.uiManager.updateVisionProcessingState(true);

                const interval = parseInt(this.uiManager.getVisionSettings().interval);
                
                // Start immediately
                this.processVisionAnalysis();
                
                // Then set up interval
                this.visionIntervalId = setInterval(() => {
                    this.processVisionAnalysis();
                }, interval);
            }

            stopVisionAnalysis() {
                this.isVisionProcessing = false;
                if (this.visionIntervalId) {
                    clearInterval(this.visionIntervalId);
                    this.visionIntervalId = null;
                }
                this.uiManager.updateVisionProcessingState(false);
            }

            async processVisionAnalysis() {
                if (!this.cameraManager.isReady) {
                    this.uiManager.showError('Camera not ready. Please check camera permissions.');
                    return;
                }

                try {
                    const instruction = this.uiManager.getInstructionText();
                    if (!instruction) {
                        this.uiManager.showError('Please enter a question about the image.');
                        return;
                    }

                    const imageResult = this.cameraManager.captureImage();
                    if (!imageResult) {
                        throw new Error('Failed to capture image');
                    }

                    const maxTokens = parseInt(this.uiManager.getVisionSettings().maxTokens);
                    const response = await this.apiClient.sendVisionAnalysis(instruction, imageResult, maxTokens);

                    this.uiManager.showVisionResponse(response);
                    console.log('VLM analysis completed:', response);

                } catch (error) {
                    console.error('Vision analysis error:', error);
                    this.uiManager.showError(`Vision analysis failed: ${error.message}`, 'vision');
                }
            }

            async processQuery() {
                const query = this.uiManager.getQueryInput();
                
                if (!query) {
                    this.uiManager.showError("Please enter a query before submitting.", 'query');
                    return;
                }

                this.uiManager.showQueryLoading();

                try {
                    const startTime = Date.now();
                    
                    const queryId = this.apiClient.generateQueryId();
                    const queryData = {
                        query_id: queryId,
                        query: query,
                        language: this.apiClient.detectLanguage(query),
                        timestamp: new Date().toISOString(),
                        user_agent: navigator.userAgent,
                        observation_id: null
                    };

                    this.apiClient.logUserQuery(queryData);

                    const response = await this.apiClient.sendStateQuery(query, queryId);
                    
                    const processingTime = Date.now() - startTime;

                    const responseText = response.response_text || response.response || 'No response received';
                    this.uiManager.showQueryResponse(responseText, response.query_type || 'State Query');

                    console.log('‚úÖ Query processed successfully:', response);

                } catch (error) {
                    console.error('Query processing error:', error);
                    this.uiManager.showError(`Query failed: ${error.message}`, 'query');
                } finally {
                    this.uiManager.hideQueryLoading();
                }
            }

            cleanup() {
                this.stopVisionAnalysis();
                this.cameraManager.cleanup();
                console.log('üßπ Application cleanup completed');
            }
        }

        // Initialize application
        let app;

        async function initializeApp() {
            try {
                console.log('üöÄ Starting Unified Vision Intelligence Hub...');

                app = new UnifiedApp();
                await app.initialize();

                console.log('‚úÖ Application started successfully');

                window.addEventListener('error', (event) => {
                    console.error('‚ùå Global error:', event.error);
                    if (app && app.uiManager) {
                        app.uiManager.showError('An unexpected error occurred. Please refresh the page.', 'global');
                    }
                });

                window.addEventListener('beforeunload', () => {
                    if (app) {
                        app.cleanup();
                    }
                });

                setInterval(() => {
                    const apiStatusDot = document.getElementById('connectionStatus');
                    if (apiStatusDot && apiStatusDot.classList.contains('status-disconnected')) {
                        app.checkBackendConnection();
                    }
                }, 30000);

            } catch (error) {
                console.error('‚ùå Failed to initialize application:', error);
            }
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }

        // Export for debugging
        window.unifiedApp = () => app;
    </script>
</body>
</html> 